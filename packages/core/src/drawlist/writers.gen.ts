// AUTO-GENERATED by scripts/generate-drawlist-writers.ts â€” do not edit manually.
// Source of truth: scripts/drawlist-spec.ts
// Regenerate: npx tsx scripts/generate-drawlist-writers.ts

import type { EncodedStyle } from "./types.js";

export const CLEAR_SIZE = 8;
export const FILL_RECT_SIZE = 52;
export const DRAW_TEXT_SIZE = 60;
export const PUSH_CLIP_SIZE = 24;
export const POP_CLIP_SIZE = 8;
export const DRAW_TEXT_RUN_SIZE = 24;
export const SET_CURSOR_SIZE = 20;
export const DRAW_CANVAS_SIZE = 32;
export const DRAW_IMAGE_SIZE = 40;
export const DEF_STRING_BASE_SIZE = 16;
export const FREE_STRING_SIZE = 12;
export const DEF_BLOB_BASE_SIZE = 16;
export const FREE_BLOB_SIZE = 12;

function align4(n: number): number {
  return (n + 3) & ~3;
}

export function writeClear(buf: Uint8Array, dv: DataView, pos: number): number {
  buf[pos + 0] = 1 & 0xff;
  buf[pos + 1] = 0;
  buf[pos + 2] = 0;
  buf[pos + 3] = 0;
  dv.setUint32(pos + 4, CLEAR_SIZE, true);
  return pos + CLEAR_SIZE;
}

export function writeFillRect(
  buf: Uint8Array,
  dv: DataView,
  pos: number,
  x: number,
  y: number,
  w: number,
  h: number,
  style: EncodedStyle,
): number {
  buf[pos + 0] = 2 & 0xff;
  buf[pos + 1] = 0;
  buf[pos + 2] = 0;
  buf[pos + 3] = 0;
  dv.setUint32(pos + 4, FILL_RECT_SIZE, true);
  dv.setInt32(pos + 8, x | 0, true);
  dv.setInt32(pos + 12, y | 0, true);
  dv.setInt32(pos + 16, w | 0, true);
  dv.setInt32(pos + 20, h | 0, true);
  dv.setUint32(pos + 24, style.fg >>> 0, true);
  dv.setUint32(pos + 28, style.bg >>> 0, true);
  dv.setUint32(pos + 32, style.attrs >>> 0, true);
  dv.setUint32(pos + 36, style.reserved >>> 0, true);
  dv.setUint32(pos + 40, style.underlineRgb >>> 0, true);
  dv.setUint32(pos + 44, style.linkUriRef >>> 0, true);
  dv.setUint32(pos + 48, style.linkIdRef >>> 0, true);
  return pos + FILL_RECT_SIZE;
}

export function writeDrawText(
  buf: Uint8Array,
  dv: DataView,
  pos: number,
  x: number,
  y: number,
  stringId: number,
  byteOff: number,
  byteLen: number,
  style: EncodedStyle,
  reserved0: number,
): number {
  buf[pos + 0] = 3 & 0xff;
  buf[pos + 1] = 0;
  buf[pos + 2] = 0;
  buf[pos + 3] = 0;
  dv.setUint32(pos + 4, DRAW_TEXT_SIZE, true);
  dv.setInt32(pos + 8, x | 0, true);
  dv.setInt32(pos + 12, y | 0, true);
  dv.setUint32(pos + 16, stringId >>> 0, true);
  dv.setUint32(pos + 20, byteOff >>> 0, true);
  dv.setUint32(pos + 24, byteLen >>> 0, true);
  dv.setUint32(pos + 28, style.fg >>> 0, true);
  dv.setUint32(pos + 32, style.bg >>> 0, true);
  dv.setUint32(pos + 36, style.attrs >>> 0, true);
  dv.setUint32(pos + 40, style.reserved >>> 0, true);
  dv.setUint32(pos + 44, style.underlineRgb >>> 0, true);
  dv.setUint32(pos + 48, style.linkUriRef >>> 0, true);
  dv.setUint32(pos + 52, style.linkIdRef >>> 0, true);
  dv.setUint32(pos + 56, reserved0 >>> 0, true);
  return pos + DRAW_TEXT_SIZE;
}

export function writePushClip(
  buf: Uint8Array,
  dv: DataView,
  pos: number,
  x: number,
  y: number,
  w: number,
  h: number,
): number {
  buf[pos + 0] = 4 & 0xff;
  buf[pos + 1] = 0;
  buf[pos + 2] = 0;
  buf[pos + 3] = 0;
  dv.setUint32(pos + 4, PUSH_CLIP_SIZE, true);
  dv.setInt32(pos + 8, x | 0, true);
  dv.setInt32(pos + 12, y | 0, true);
  dv.setInt32(pos + 16, w | 0, true);
  dv.setInt32(pos + 20, h | 0, true);
  return pos + PUSH_CLIP_SIZE;
}

export function writePopClip(buf: Uint8Array, dv: DataView, pos: number): number {
  buf[pos + 0] = 5 & 0xff;
  buf[pos + 1] = 0;
  buf[pos + 2] = 0;
  buf[pos + 3] = 0;
  dv.setUint32(pos + 4, POP_CLIP_SIZE, true);
  return pos + POP_CLIP_SIZE;
}

export function writeDrawTextRun(
  buf: Uint8Array,
  dv: DataView,
  pos: number,
  x: number,
  y: number,
  blobId: number,
  reserved0: number,
): number {
  buf[pos + 0] = 6 & 0xff;
  buf[pos + 1] = 0;
  buf[pos + 2] = 0;
  buf[pos + 3] = 0;
  dv.setUint32(pos + 4, DRAW_TEXT_RUN_SIZE, true);
  dv.setInt32(pos + 8, x | 0, true);
  dv.setInt32(pos + 12, y | 0, true);
  dv.setUint32(pos + 16, blobId >>> 0, true);
  dv.setUint32(pos + 20, reserved0 >>> 0, true);
  return pos + DRAW_TEXT_RUN_SIZE;
}

export function writeSetCursor(
  buf: Uint8Array,
  dv: DataView,
  pos: number,
  x: number,
  y: number,
  shape: number,
  visible: number,
  blink: number,
  reserved0: number,
): number {
  buf[pos + 0] = 7 & 0xff;
  buf[pos + 1] = 0;
  buf[pos + 2] = 0;
  buf[pos + 3] = 0;
  dv.setUint32(pos + 4, SET_CURSOR_SIZE, true);
  dv.setInt32(pos + 8, x | 0, true);
  dv.setInt32(pos + 12, y | 0, true);
  buf[pos + 16] = shape & 0xff;
  buf[pos + 17] = visible & 0xff;
  buf[pos + 18] = blink & 0xff;
  buf[pos + 19] = reserved0 & 0xff;
  return pos + SET_CURSOR_SIZE;
}

export function writeDrawCanvas(
  buf: Uint8Array,
  dv: DataView,
  pos: number,
  x: number,
  y: number,
  w: number,
  h: number,
  pxWidth: number,
  pxHeight: number,
  blobId: number,
  reservedBlob: number,
  blitterCode: number,
  reserved0: number,
  reserved1: number,
): number {
  buf[pos + 0] = 8 & 0xff;
  buf[pos + 1] = 0;
  buf[pos + 2] = 0;
  buf[pos + 3] = 0;
  dv.setUint32(pos + 4, DRAW_CANVAS_SIZE, true);
  dv.setUint16(pos + 8, x & 0xffff, true);
  dv.setUint16(pos + 10, y & 0xffff, true);
  dv.setUint16(pos + 12, w & 0xffff, true);
  dv.setUint16(pos + 14, h & 0xffff, true);
  dv.setUint16(pos + 16, pxWidth & 0xffff, true);
  dv.setUint16(pos + 18, pxHeight & 0xffff, true);
  dv.setUint32(pos + 20, blobId >>> 0, true);
  dv.setUint32(pos + 24, reservedBlob >>> 0, true);
  buf[pos + 28] = blitterCode & 0xff;
  buf[pos + 29] = reserved0 & 0xff;
  dv.setUint16(pos + 30, reserved1 & 0xffff, true);
  return pos + DRAW_CANVAS_SIZE;
}

export function writeDrawImage(
  buf: Uint8Array,
  dv: DataView,
  pos: number,
  x: number,
  y: number,
  w: number,
  h: number,
  pxWidth: number,
  pxHeight: number,
  blobId: number,
  reservedBlob: number,
  imageId: number,
  formatCode: number,
  protocolCode: number,
  zLayer: number,
  fitCode: number,
  reserved0: number,
  reserved1: number,
  reserved2: number,
): number {
  buf[pos + 0] = 9 & 0xff;
  buf[pos + 1] = 0;
  buf[pos + 2] = 0;
  buf[pos + 3] = 0;
  dv.setUint32(pos + 4, DRAW_IMAGE_SIZE, true);
  dv.setUint16(pos + 8, x & 0xffff, true);
  dv.setUint16(pos + 10, y & 0xffff, true);
  dv.setUint16(pos + 12, w & 0xffff, true);
  dv.setUint16(pos + 14, h & 0xffff, true);
  dv.setUint16(pos + 16, pxWidth & 0xffff, true);
  dv.setUint16(pos + 18, pxHeight & 0xffff, true);
  dv.setUint32(pos + 20, blobId >>> 0, true);
  dv.setUint32(pos + 24, reservedBlob >>> 0, true);
  dv.setUint32(pos + 28, imageId >>> 0, true);
  buf[pos + 32] = formatCode & 0xff;
  buf[pos + 33] = protocolCode & 0xff;
  buf[pos + 34] = zLayer & 0xff;
  buf[pos + 35] = fitCode & 0xff;
  buf[pos + 36] = reserved0 & 0xff;
  buf[pos + 37] = reserved1 & 0xff;
  dv.setUint16(pos + 38, reserved2 & 0xffff, true);
  return pos + DRAW_IMAGE_SIZE;
}

export function writeDefString(
  buf: Uint8Array,
  dv: DataView,
  pos: number,
  stringId: number,
  byteLen: number,
  bytes: Uint8Array,
): number {
  const payloadBytes = byteLen >>> 0;
  const size = align4(DEF_STRING_BASE_SIZE + payloadBytes);
  buf[pos + 0] = 10 & 0xff;
  buf[pos + 1] = 0;
  buf[pos + 2] = 0;
  buf[pos + 3] = 0;
  dv.setUint32(pos + 4, size >>> 0, true);
  dv.setUint32(pos + 8, stringId >>> 0, true);
  dv.setUint32(pos + 12, payloadBytes >>> 0, true);
  const dataStart = pos + DEF_STRING_BASE_SIZE;
  const copyBytes = Math.min(payloadBytes, bytes.byteLength >>> 0);
  if (copyBytes > 0) {
    buf.set(bytes.subarray(0, copyBytes), dataStart);
  }
  if (payloadBytes > copyBytes) {
    buf.fill(0, dataStart + copyBytes, dataStart + payloadBytes);
  }
  const payloadEnd = dataStart + payloadBytes;
  const cmdEnd = pos + size;
  if (cmdEnd > payloadEnd) {
    buf.fill(0, payloadEnd, cmdEnd);
  }
  return pos + size;
}

export function writeFreeString(
  buf: Uint8Array,
  dv: DataView,
  pos: number,
  stringId: number,
): number {
  buf[pos + 0] = 11 & 0xff;
  buf[pos + 1] = 0;
  buf[pos + 2] = 0;
  buf[pos + 3] = 0;
  dv.setUint32(pos + 4, FREE_STRING_SIZE, true);
  dv.setUint32(pos + 8, stringId >>> 0, true);
  return pos + FREE_STRING_SIZE;
}

export function writeDefBlob(
  buf: Uint8Array,
  dv: DataView,
  pos: number,
  blobId: number,
  byteLen: number,
  bytes: Uint8Array,
): number {
  const payloadBytes = byteLen >>> 0;
  const size = align4(DEF_BLOB_BASE_SIZE + payloadBytes);
  buf[pos + 0] = 12 & 0xff;
  buf[pos + 1] = 0;
  buf[pos + 2] = 0;
  buf[pos + 3] = 0;
  dv.setUint32(pos + 4, size >>> 0, true);
  dv.setUint32(pos + 8, blobId >>> 0, true);
  dv.setUint32(pos + 12, payloadBytes >>> 0, true);
  const dataStart = pos + DEF_BLOB_BASE_SIZE;
  const copyBytes = Math.min(payloadBytes, bytes.byteLength >>> 0);
  if (copyBytes > 0) {
    buf.set(bytes.subarray(0, copyBytes), dataStart);
  }
  if (payloadBytes > copyBytes) {
    buf.fill(0, dataStart + copyBytes, dataStart + payloadBytes);
  }
  const payloadEnd = dataStart + payloadBytes;
  const cmdEnd = pos + size;
  if (cmdEnd > payloadEnd) {
    buf.fill(0, payloadEnd, cmdEnd);
  }
  return pos + size;
}

export function writeFreeBlob(buf: Uint8Array, dv: DataView, pos: number, blobId: number): number {
  buf[pos + 0] = 13 & 0xff;
  buf[pos + 1] = 0;
  buf[pos + 2] = 0;
  buf[pos + 3] = 0;
  dv.setUint32(pos + 4, FREE_BLOB_SIZE, true);
  dv.setUint32(pos + 8, blobId >>> 0, true);
  return pos + FREE_BLOB_SIZE;
}
