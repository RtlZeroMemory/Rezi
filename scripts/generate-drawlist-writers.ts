import { mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { dirname, join } from "node:path";
import { fileURLToPath } from "node:url";
import {
  COMMAND_HEADER_SIZE,
  DRAWLIST_COMMAND_SPECS,
  type DrawlistCommandSpec,
  type DrawlistFieldSpec,
  type DrawlistFieldType,
  STYLE_FIELDS,
} from "./drawlist-spec.js";

type Emission = Readonly<{
  lines: readonly string[];
  usesStyle: boolean;
}>;

const FIELD_SIZE: Readonly<Record<Exclude<DrawlistFieldType, "style">, number>> = Object.freeze({
  u8: 1,
  i8: 1,
  u16: 2,
  u32: 4,
  i32: 4,
});

function fieldByteSize(field: DrawlistFieldSpec): number {
  if (field.type === "style") return 28;
  return FIELD_SIZE[field.type];
}

function validateSpec(commands: readonly DrawlistCommandSpec[]): void {
  for (const cmd of commands) {
    if (cmd.totalSize < COMMAND_HEADER_SIZE || (cmd.totalSize & 3) !== 0) {
      throw new Error(
        `${cmd.name}: totalSize must be >= ${String(COMMAND_HEADER_SIZE)} and 4-byte aligned`,
      );
    }

    let prevOffset = COMMAND_HEADER_SIZE;
    for (const field of cmd.fields) {
      const size = fieldByteSize(field);
      if (field.offset < COMMAND_HEADER_SIZE) {
        throw new Error(
          `${cmd.name}.${field.name}: offset must be >= ${String(COMMAND_HEADER_SIZE)}`,
        );
      }
      if (field.offset < prevOffset) {
        throw new Error(`${cmd.name}.${field.name}: fields must be sorted by ascending offsets`);
      }
      if (field.offset + size > cmd.totalSize) {
        throw new Error(
          `${cmd.name}.${field.name}: field exceeds command size (end=${String(field.offset + size)}, size=${String(cmd.totalSize)})`,
        );
      }
      prevOffset = field.offset + size;
    }

    if (prevOffset !== cmd.totalSize) {
      throw new Error(
        `${cmd.name}: payload layout does not fully cover command bytes (ended at ${String(prevOffset)}, expected ${String(cmd.totalSize)})`,
      );
    }
  }
}

function emitFieldWrite(field: DrawlistFieldSpec): Emission {
  const off = `pos + ${field.offset}`;
  switch (field.type) {
    case "u32":
      return { lines: [`dv.setUint32(${off}, ${field.name} >>> 0, true);`], usesStyle: false };
    case "i32":
      return { lines: [`dv.setInt32(${off}, ${field.name} | 0, true);`], usesStyle: false };
    case "u16":
      return { lines: [`dv.setUint16(${off}, ${field.name} & 0xffff, true);`], usesStyle: false };
    case "u8":
    case "i8":
      return { lines: [`buf[${off}] = ${field.name} & 0xff;`], usesStyle: false };
    case "style": {
      const lines = STYLE_FIELDS.map(
        (styleKey, idx) =>
          `dv.setUint32(pos + ${field.offset + idx * 4}, ${field.name}.${styleKey} >>> 0, true);`,
      );
      return { lines, usesStyle: true };
    }
    default: {
      const _never: never = field.type;
      throw new Error(`unsupported field type: ${String(_never)}`);
    }
  }
}

function emitFunction(command: DrawlistCommandSpec): Emission {
  const params: string[] = ["buf: Uint8Array", "dv: DataView", "pos: number"];
  for (const field of command.fields) {
    params.push(`${field.name}: ${field.type === "style" ? "EncodedStyle" : "number"}`);
  }

  const body: string[] = [];
  body.push(`buf[pos + 0] = ${command.opcode} & 0xff;`);
  body.push("buf[pos + 1] = 0;");
  body.push("buf[pos + 2] = 0;");
  body.push("buf[pos + 3] = 0;");
  body.push(`dv.setUint32(pos + 4, ${command.name}_SIZE, true);`);

  let usesStyle = false;
  for (const field of command.fields) {
    const write = emitFieldWrite(field);
    body.push(...write.lines);
    usesStyle ||= write.usesStyle;
  }
  body.push(`return pos + ${command.name}_SIZE;`);

  const lines: string[] = [];
  if (params.length <= 3) {
    lines.push(`export function ${command.writerName}(${params.join(", ")}): number {`);
  } else {
    lines.push(`export function ${command.writerName}(`);
    for (const param of params) {
      lines.push(`  ${param},`);
    }
    lines.push("): number {");
  }
  lines.push(...body.map((line) => `  ${line}`));
  lines.push("}");
  return { lines, usesStyle };
}

function generateSource(commands: readonly DrawlistCommandSpec[]): string {
  const blocks: string[] = [
    "// AUTO-GENERATED by scripts/generate-drawlist-writers.ts â€” do not edit manually.",
    "// Source of truth: scripts/drawlist-spec.ts",
    "// Regenerate: npx tsx scripts/generate-drawlist-writers.ts",
    "",
  ];

  const fnLines: string[] = [];
  let needsStyleImport = false;

  for (const command of commands) {
    fnLines.push(`export const ${command.name}_SIZE = ${command.totalSize};`);
  }
  fnLines.push("");

  for (const command of commands) {
    const emitted = emitFunction(command);
    needsStyleImport ||= emitted.usesStyle;
    fnLines.push(...emitted.lines);
    fnLines.push("");
  }

  if (needsStyleImport) {
    blocks.push('import type { EncodedStyle } from "./types.js";');
    blocks.push("");
  }

  blocks.push(...fnLines);
  return `${blocks.join("\n").trimEnd()}\n`;
}

function writeIfChanged(path: string, next: string): "created" | "updated" | "unchanged" {
  const prev = (() => {
    try {
      return readFileSync(path, "utf8");
    } catch {
      return null;
    }
  })();

  if (prev === next) return "unchanged";
  mkdirSync(dirname(path), { recursive: true });
  writeFileSync(path, next, "utf8");
  return prev === null ? "created" : "updated";
}

function checkUpToDate(path: string, next: string): boolean {
  const prev = (() => {
    try {
      return readFileSync(path, "utf8");
    } catch {
      return null;
    }
  })();
  return prev === next;
}

function main(): void {
  validateSpec(DRAWLIST_COMMAND_SPECS);
  const src = generateSource(DRAWLIST_COMMAND_SPECS);
  const root = join(dirname(fileURLToPath(import.meta.url)), "..");
  const outPath = join(root, "packages/core/src/drawlist/writers.gen.ts");
  const checkMode = process.argv.includes("--check");

  if (checkMode) {
    if (!checkUpToDate(outPath, src)) {
      console.error(
        "drawlist writers are out of date. Run: npx tsx scripts/generate-drawlist-writers.ts",
      );
      process.exitCode = 1;
      return;
    }
    console.log(`drawlist writers: up-to-date (${outPath})`);
    return;
  }

  const result = writeIfChanged(outPath, src);
  console.log(`drawlist writers: ${result} (${outPath})`);
}

main();
